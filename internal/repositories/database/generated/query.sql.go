// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getOrderByNumber = `-- name: GetOrderByNumber :one
SELECT number, uploaded_at, user_login, status, accrual
FROM orders
WHERE number = $1
`

func (q *Queries) GetOrderByNumber(ctx context.Context, number string) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByNumber, number)
	var i Order
	err := row.Scan(
		&i.Number,
		&i.UploadedAt,
		&i.UserLogin,
		&i.Status,
		&i.Accrual,
	)
	return i, err
}

const getOrdersWithStatus = `-- name: GetOrdersWithStatus :many
SELECT number, uploaded_at, user_login, status, accrual
FROM orders
WHERE status = $1
`

func (q *Queries) GetOrdersWithStatus(ctx context.Context, status pgtype.Text) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersWithStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.Number,
			&i.UploadedAt,
			&i.UserLogin,
			&i.Status,
			&i.Accrual,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnprocessedOrders = `-- name: GetUnprocessedOrders :many
SELECT number, uploaded_at, user_login, status, accrual
FROM orders
WHERE status in ('NEW', 'PROCESSING')
`

func (q *Queries) GetUnprocessedOrders(ctx context.Context) ([]Order, error) {
	rows, err := q.db.Query(ctx, getUnprocessedOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.Number,
			&i.UploadedAt,
			&i.UserLogin,
			&i.Status,
			&i.Accrual,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT login, password, current, withdrawn
FROM users
WHERE login = $1
`

func (q *Queries) GetUser(ctx context.Context, login string) (User, error) {
	row := q.db.QueryRow(ctx, getUser, login)
	var i User
	err := row.Scan(
		&i.Login,
		&i.Password,
		&i.Current,
		&i.Withdrawn,
	)
	return i, err
}

const getUserOrders = `-- name: GetUserOrders :many
SELECT number, uploaded_at, user_login, status, accrual
FROM orders
WHERE user_login = $1
ORDER BY uploaded_at DESC
`

func (q *Queries) GetUserOrders(ctx context.Context, userLogin string) ([]Order, error) {
	rows, err := q.db.Query(ctx, getUserOrders, userLogin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.Number,
			&i.UploadedAt,
			&i.UserLogin,
			&i.Status,
			&i.Accrual,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithdrawals = `-- name: GetUserWithdrawals :many
SELECT number, processed_at, user_login, sum
FROM withdrawals
WHERE user_login = $1
ORDER BY processed_at DESC
`

func (q *Queries) GetUserWithdrawals(ctx context.Context, userLogin string) ([]Withdrawal, error) {
	rows, err := q.db.Query(ctx, getUserWithdrawals, userLogin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Withdrawal
	for rows.Next() {
		var i Withdrawal
		if err := rows.Scan(
			&i.Number,
			&i.ProcessedAt,
			&i.UserLogin,
			&i.Sum,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerUser = `-- name: RegisterUser :exec
INSERT INTO users (login, password)
VALUES ($1, $2)
`

type RegisterUserParams struct {
	Login    string `json:"login"`
	Password []byte `json:"password"`
}

func (q *Queries) RegisterUser(ctx context.Context, arg RegisterUserParams) error {
	_, err := q.db.Exec(ctx, registerUser, arg.Login, arg.Password)
	return err
}

const updateOrderAccrual = `-- name: UpdateOrderAccrual :exec
UPDATE orders
SET accrual = $2
WHERE number = $1
`

type UpdateOrderAccrualParams struct {
	Number  string        `json:"number"`
	Accrual pgtype.Float4 `json:"accrual"`
}

func (q *Queries) UpdateOrderAccrual(ctx context.Context, arg UpdateOrderAccrualParams) error {
	_, err := q.db.Exec(ctx, updateOrderAccrual, arg.Number, arg.Accrual)
	return err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
UPDATE orders
SET status = $2
WHERE number = $1
`

type UpdateOrderStatusParams struct {
	Number string      `json:"number"`
	Status pgtype.Text `json:"status"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) error {
	_, err := q.db.Exec(ctx, updateOrderStatus, arg.Number, arg.Status)
	return err
}

const updateUserBalance = `-- name: UpdateUserBalance :exec
UPDATE users
SET current = current + $2, withdrawn = withdrawn + $3
WHERE login = $1
`

type UpdateUserBalanceParams struct {
	Login     string        `json:"login"`
	Current   pgtype.Float4 `json:"current"`
	Withdrawn pgtype.Float4 `json:"withdrawn"`
}

func (q *Queries) UpdateUserBalance(ctx context.Context, arg UpdateUserBalanceParams) error {
	_, err := q.db.Exec(ctx, updateUserBalance, arg.Login, arg.Current, arg.Withdrawn)
	return err
}

const uploadOrder = `-- name: UploadOrder :exec
INSERT INTO orders (number, user_login)
VALUES ($1, $2)
`

type UploadOrderParams struct {
	Number    string `json:"number"`
	UserLogin string `json:"user_login"`
}

func (q *Queries) UploadOrder(ctx context.Context, arg UploadOrderParams) error {
	_, err := q.db.Exec(ctx, uploadOrder, arg.Number, arg.UserLogin)
	return err
}

const uploadWithdrawal = `-- name: UploadWithdrawal :exec
INSERT INTO withdrawals (number, user_login, sum)
VALUES ($1, $2, $3)
`

type UploadWithdrawalParams struct {
	Number    string        `json:"number"`
	UserLogin string        `json:"user_login"`
	Sum       pgtype.Float4 `json:"sum"`
}

func (q *Queries) UploadWithdrawal(ctx context.Context, arg UploadWithdrawalParams) error {
	_, err := q.db.Exec(ctx, uploadWithdrawal, arg.Number, arg.UserLogin, arg.Sum)
	return err
}
